#!/usr/bin/env python
import os
import sys
import pwd
import imp
from uuid import uuid4
from glob import iglob
from datetime import datetime

_CONFIG_FILE_NAME="config"
_DATA_DIR=".later"

_CONFIG={
	"default_priority": 0,
}
_HOOKS=dict()
def hooked(fun):
	"""Decorator: make function available via _HOOKS"""
	_HOOKS[fun.__name__] = fun

def find_config():
	"""Find config file starting from current directory upwards."""
	current = os.path.abspath(os.path.curdir)
	trash = None
	while len(current) > 1:
		data = os.path.join(current, _DATA_DIR)
		config = os.path.join(data, _CONFIG_FILE_NAME)
		if os.path.isdir(data) and os.path.isfile(config):
			return config
		current, trash = os.path.split(current)

def determine_user():
	if "username" in _CONFIG and _CONFIG["username"] != "":
		return # already there
	_CONFIG["username"] = _HOOKS["guess_username"]()

@hooked
def guess_username():
	# try user login name
	return pwd.getpwuid(os.getuid())[0]

def load_plugins():
	for path in iglob(os.path.join(_CONFIG["data_dir"], "*.py")):
		name = os.path.basename(path)[:-3]
		mod = imp.load_source("plugin:"+name, path)
		mod.plugin_init(_HOOKS)

def load_config():
	"""Load config from file"""
	path = find_config()
	if os.path.isfile(path):
		for line in open(path):
			i = line.index(": ")
			_CONFIG[line[:i]] = line[i+2:-1]
		_CONFIG["data_dir"] = os.path.dirname(path)
	load_plugins()
	determine_user()

def store_config(path, **overwrite):
	"""Store config to file"""
	fh = open(path, 'w')
	for key,val in overwrite.items():
		_CONFIG[key] = val
	for key,val in _CONFIG.items():
		if key == "data_dir": continue
		fh.write("%s: %s\n" % (key,val))
	fh.close()

_PROPERTY_CHARS="abcdefghijklmnopqrstuvwxyz_"
def is_property_line(line):
	for i,c in enumerate(line):
		if not c in _PROPERTY_CHARS:
			if i > 0 and c == ":":
				return True
			else:
				return False
	return False
			
def load_lfile(path):
	fh = open(path)
	props = dict()
	line = fh.readline()
	while is_property_line(line):
		i = line.index(":")
		props[line[:i]] = line[i+1:].strip()
		line = fh.readline()
	msg = ""
	while line:
		msg += line
		line = fh.readline()
	return msg.strip(), props

def store_lfile(path, msg, props):
	fh = open(path, 'w')
	for key,val in props.items():
		fh.write("%s: %s\n" % (key,val))
	fh.write("\n")
	fh.write(msg)
	fh.write("\n")
	fh.close()

def serialize_datetime(dt):
	return dt.strftime("%Y-%m-%dT%H:%M:%S%z")

def complete_guid(halfguid):
	if len(halfguid) == 36:
		return halfguid # already complete
	found = None
	for path in iglob(os.path.join(_CONFIG["data_dir"], "*.issue")):
		guid = os.path.basename(path)[:-6]
		if guid.startswith(halfguid):
			if found:
				print "The guid part is ambiguous:"
				print guid, "or"
				print found, "?"
				return
			else:
				found = guid
	return found

class Issue:
	def __init__(self, guid=None):
		self.msg = "Something is rotten ..."
		self.properties = dict(
				status="reported",
				#priority=_CONFIG["default_priority"],
				responsible="nobody",
				created=serialize_datetime(datetime.utcnow()),
				reporter=_HOOKS["guess_username"]())
		if guid:
			self.guid = guid
			self._load()
		else:
			self.guid = str(uuid4())
		self.filename = self._genPath()
	def _genPath(self):
		return os.path.join(_CONFIG["data_dir"], self.guid + ".issue")
	def _load(self):
		m, p = load_lfile(self._genPath())
		self.msg = m
		for key,val in p.items():
			self.properties[key] = val
	def store(self):
		"""Store issue data to file system"""
		self.properties["modified"] = serialize_datetime(datetime.utcnow())
		store_lfile(self._genPath(), self.msg, self.properties)
	def shortString(self):
		"""One line representation"""
		i = self.msg.find("\n")
		if i < 0:
			i = None
		string = self.msg[:i]
		status = self.properties.get("status", "?")
		return " %-50s\t(%s, %s)" % (string, status, self.guid[:8])

# explicitly not @hooked.
def cmd_init(args):
	"""Create a new data directory for issues in the current dir."""
	try:
		os.mkdir(_DATA_DIR)
	except OSError, e:
		print "Could not create data directory:", e
		return
	store_config(os.path.join(_DATA_DIR, _CONFIG_FILE_NAME))

@hooked
def cmd_add(args):
	"""Quickly add a new issue by specifying only a message."""
	issue = Issue()
	issue.msg = args.pop(0)
	issue.store()
	print "Issue stored as", issue.guid

@hooked
def cmd_list(args):
	"""Lists all issues, which are not closed."""
	for path in iglob(os.path.join(_CONFIG["data_dir"], "*.issue")):
		guid = os.path.basename(path)[:-6]
		issue = Issue(guid)
		if issue.properties["status"] != "closed":
			print issue.shortString()

@hooked
def cmd_edit(args):
	"""Edit a specific issue.
If none specified a new issue is generated (like add does.)"""
	try:
		guid = complete_guid(args[0])
		if not guid:
			return
	except IndexError:
		guid = None
	editor = os.getenv("EDITOR")
	if not editor:
		print "Error: no $EDITOR environment variable"
		return
	issue = Issue(guid)
	if not guid:
		issue.store() # generate skeleton
	cmd = "%s %s" % (editor, issue.filename)
	os.system(cmd)
	issue = Issue(guid)
	issue.store() # updates modified property
	if not guid: # generated a new issue
		print "Issue stored as", issue.guid

@hooked
def cmd_show(args):
	"""Show a specific issue."""
	if not args:
		print "Error: need guid argument"
		return
	guid = complete_guid(args[0])
	if not guid:
		return
	issue = Issue(guid)
	print open(issue.filename).read()

@hooked
def cmd_close(args):
	"""Mark a specific issue as done."""
	if not args:
		print "Error: need guid argument"
		return
	guid = complete_guid(args[0])
	if not guid:
		return
	issue = Issue(guid)
	issue.properties["status"] = "closed"
	issue.store()

_USAGE = """\
A command-line issue tracker for a lazy developer.
Usage is "%s <cmd> ...", where <cmd> is one of

init            create a data dir in the current directory
add "foo bar"   report new issue with message "foo bar"
edit <guid>     edit issue with the given guid (no guid creates new issue)
close <gui>     mark an issue as done
list            show all issues in short
show <guid>     show issue <guid> completely
help <cmd>      shows documentation for one of the commands
""" % (sys.argv[0])

@hooked
def cmd_help(args):
	"""Provides general usage and help for every command."""
	if len(args) == 0:
		print _USAGE
		return
	fun = _HOOKS.get("cmd_" + args[0], None)
	if not fun:
		print "Can not help you with that. Typo?"
		return
	# print docstring as help for a specific command
	print fun.__doc__

def main():
	if len(sys.argv) <= 1:
		print "Error: No command given. Try 'help'."
		return
	if sys.argv[1] == "init":
		cmd_init(sys.argv[2:])
		return
	load_config()
	# e.g. "add" leads to calling "cmd_add"
	fun = _HOOKS.get("cmd_" + sys.argv[1], None)
	if not fun:
		print "Error: Unknown command. Try 'help'."
		return
	fun(sys.argv[2:])

if __name__ == "__main__":
	main()

