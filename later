#!/usr/bin/env python
import os
import sys
import pwd
import imp
from uuid import uuid4
from glob import iglob
from datetime import datetime
from tempfile import mkstemp

_CONFIG_FILE_NAME="config"
_DATA_DIR=".later"

_CONFIG={
	"default_priority": 0,
}

class Hooks(object):
	def __getitem__(self, key):
		return self.__dict__[key]
	def __setitem__(self, key, value):
		self.__dict__[key] = value
	def get(self, key, default=None):
		return self.__dict__.get(key, default)

_HOOKS=Hooks()
def hooked(fun):
	"""Decorator: make function available via _HOOKS"""
	_HOOKS[fun.__name__] = fun

def find_config():
	"""Find config file starting from current directory upwards."""
	current = os.path.abspath(os.path.curdir)
	trash = None
	while len(current) > 1:
		data = os.path.join(current, _DATA_DIR)
		config = os.path.join(data, _CONFIG_FILE_NAME)
		if os.path.isdir(data) and os.path.isfile(config):
			return config
		current, trash = os.path.split(current)

@hooked
def guess_username():
	# try user login name
	return pwd.getpwuid(os.getuid())[0]

def load_plugins():
	for path in iglob(os.path.join(_CONFIG["data_dir"], "*.py")):
		name = os.path.basename(path)[:-3]
		mod = imp.load_source("plugin:"+name, path)
		mod.plugin_init(_HOOKS)

def load_config():
	"""Load config from file"""
	path = find_config()
	if os.path.isfile(path):
		for line in open(path):
			i = line.index(": ")
			_CONFIG[line[:i]] = line[i+2:-1]
		_CONFIG["data_dir"] = os.path.dirname(path)
	load_plugins()
	if not _CONFIG.get("username", None):
		_CONFIG["username"] = _HOOKS.guess_username()

def store_config(path):
	"""Store config to file"""
	fh = open(path, 'w')
	for key,val in _CONFIG.items():
		if key == "data_dir": continue
		fh.write("%s: %s\n" % (key,val))
	fh.close()

_PROPERTY_CHARS="abcdefghijklmnopqrstuvwxyz_"
def is_property_line(line):
	for i,c in enumerate(line):
		if not c in _PROPERTY_CHARS:
			if i > 0 and c == ":":
				return True
			else:
				return False
	return False
			
def load_lfile(path):
	fh = open(path)
	props = dict()
	line = fh.readline()
	while is_property_line(line):
		i = line.index(":")
		props[line[:i]] = line[i+1:].strip()
		line = fh.readline()
	msg = ""
	while line:
		msg += line
		line = fh.readline()
	return msg.strip(), props

def store_lfile(path, msg, props):
	fh = open(path, 'w')
	for key,val in props.items():
		fh.write("%s: %s\n" % (key,val))
	fh.write("\n")
	fh.write(msg)
	fh.write("\n")
	fh.close()

def serialize_datetime(dt):
	return dt.strftime("%Y-%m-%dT%H:%M:%S%z")

class Issue:
	def __init__(self, guid=None, properties=dict(), message="Something is rotten ..."):
		self.properties = dict(
				status="reported",
				#priority=_CONFIG["default_priority"],
				responsible="nobody",
				created=serialize_datetime(datetime.utcnow()),
				reporter=_HOOKS.guess_username())
		for k,v in properties.items():
			self.properties[k] = v
		self.msg = message
		self.guid = guid or str(uuid4())
	def shortString(self):
		"""One line representation"""
		i = self.msg.find("\n")
		if i < 0:
			i = None
		string = self.msg[:i]
		status = self.properties.get("status", "?")
		return " %-50s\t(%s, %s)" % (string, status, self.guid[:8])
	def longString(self):
		"""Multi line representation"""
		string = "%s\n" % (self.guid)
		for k,v in self.properties.items():
			string += "%s: %s\n" % (k,v)
		string += "\n" + self.msg
		return string

# explicitly not @hooked, since backend specific
def be_gen_path(guid):
	return os.path.join(_CONFIG["data_dir"], guid + ".issue")

@hooked
def be_all_guids():
	for path in iglob(be_gen_path("*")):
		yield os.path.basename(path)[:-6]

@hooked
def be_complete_guid(halfguid):
	if len(halfguid) == 36:
		return halfguid # already complete
	found = None
	for guid in _HOOKS.be_all_guids():
		if guid.startswith(halfguid):
			if found:
				print "The guid part is ambiguous:"
				print guid, "or"
				print found, "?"
				return
			else:
				found = guid
	return found

@hooked
def be_store_issue(issue):
	issue.properties["modified"] = serialize_datetime(datetime.utcnow())
	store_lfile(be_gen_path(issue.guid), issue.msg, issue.properties)

@hooked
def be_load_issue(guid):
	assert len(guid) == 36
	path = be_gen_path(guid)
	m, p = load_lfile(path)
	return Issue(guid, p, m)

# explicitly not @hooked, since now plugins available at this point
def cmd_init(args):
	"""Create a new data directory for issues in the current dir."""
	try:
		os.mkdir(_DATA_DIR)
	except OSError, e:
		print "Could not create data directory:", e
		return
	store_config(os.path.join(_DATA_DIR, _CONFIG_FILE_NAME))

@hooked
def cmd_add(args):
	"""Quickly add a new issue by specifying only a message."""
	issue = Issue()
	issue.msg = args.pop(0)
	_HOOKS.be_store_issue(issue)
	print "issue stored as", issue.guid

@hooked
def cmd_list(args):
	"""Lists all issues, which are not closed."""
	for guid in _HOOKS.be_all_guids():
		issue = _HOOKS.be_load_issue(guid)
		if issue.properties["status"] != "closed":
			print issue.shortString()

@hooked
def cmd_edit(args):
	"""Edit a specific issue.
If none specified a new issue is generated (like add does.)"""
	try:
		guid = _HOOKS.be_complete_guid(args[0])
		if not guid:
			return
	except IndexError:
		guid = None
	editor = os.getenv("EDITOR")
	if not editor:
		print "Error: no $EDITOR environment variable"
		return
	issue = _HOOKS.be_load_issue(guid)
	fh, filename = mkstemp(".issue")
	store_lfile(filename, issue.msg, issue.properties)
	cmd = "%s %s" % (editor, filename)
	os.system(cmd)
	m,p = load_lfile(filename)
	issue = Issue(issue.guid, p, m)
	_HOOKS.be_store_issue(issue) # updates modified properties
	if not guid: # generated a new issue
		print "Issue stored as", issue.guid

@hooked
def cmd_show(args):
	"""Show a specific issue."""
	if not args:
		print "Error: need guid argument"
		return
	guid = _HOOKS.be_complete_guid(args[0])
	if not guid:
		return
	issue = _HOOKS.be_load_issue(guid)
	print issue.longString()

@hooked
def cmd_close(args):
	"""Mark a specific issue as done."""
	if not args:
		print "Error: need guid argument"
		return
	guid = _HOOKS.be_complete_guid(args[0])
	if not guid:
		return
	issue = _HOOKS.be_load_issue(guid)
	issue.properties["status"] = "closed"
	_HOOKS.be_store_issue(issue)

_USAGE = """\
A command-line issue tracker for a lazy developer.
Usage is "%s <cmd> ...", where <cmd> is one of

init            create a data dir in the current directory
add "foo bar"   report new issue with message "foo bar"
edit <guid>     edit issue with the given guid (no guid creates new issue)
close <gui>     mark an issue as done
list            show all issues in short
show <guid>     show issue <guid> completely
help <cmd>      shows documentation for one of the commands
""" % (sys.argv[0])

@hooked
def cmd_help(args):
	"""Provides general usage and help for every command."""
	if len(args) == 0:
		print _USAGE
		return
	fun = _HOOKS.get("cmd_" + args[0], None)
	if not fun:
		print "Can not help you with that. Typo?"
		return
	# print docstring as help for a specific command
	print fun.__doc__

def main():
	if len(sys.argv) <= 1:
		print "Error: No command given. Try 'help'."
		return
	if sys.argv[1] == "init":
		cmd_init(sys.argv[2:])
		return
	load_config()
	# e.g. "add" leads to calling "cmd_add"
	fun = _HOOKS.get("cmd_" + sys.argv[1], None)
	if not fun:
		print "Error: Unknown command. Try 'help'."
		return
	fun(sys.argv[2:])

if __name__ == "__main__":
	main()

